use std::fs;
use std::io::Write;
use std::io::{self};
use std::path::PathBuf;

use anyhow::Context;
use anyhow::Result;
use anyhow::anyhow;
use base64::Engine as _;
use base64::engine::general_purpose::URL_SAFE_NO_PAD;
use reqwest::StatusCode;
use reqwest::blocking::Client;
use serde::Deserialize;
use serde::Serialize;
use serde_json::Value;
use uuid::Uuid;

const CLIENT_ID: &str = "app_EMoamEEZ73f0CkXaXp7hrann";
const CHATGPT_BASE_URL: &str = "https://chatgpt.com/backend-api";
const CHATGPT_MODEL: &str = "gpt-5-codex";
const OPENAI_RESPONSES_URL: &str = "https://api.openai.com/v1/responses";
const DEFAULT_INSTRUCTIONS: &str = include_str!("../../core/gpt_5_codex_prompt.md");

#[derive(Debug, Deserialize)]
struct AuthJson {
    #[serde(rename = "OPENAI_API_KEY")]
    openai_api_key: Option<String>,
    #[serde(default)]
    tokens: Option<TokenBundle>,
}

#[derive(Debug, Deserialize, Clone)]
struct TokenBundle {
    id_token: String,
    #[serde(default)]
    access_token: Option<String>,
    #[serde(default)]
    refresh_token: Option<String>,
}

#[derive(Debug)]
enum Credential {
    ApiKey(String),
    ChatGpt(TokenBundle),
}

#[derive(Debug, Serialize)]
struct ChatRequest<'a> {
    model: &'a str,
    input: Vec<ChatInput<'a>>,
    instructions: &'a str,
    stream: bool,
    store: bool,
}

#[derive(Debug, Serialize)]
struct ChatInput<'a> {
    role: &'a str,
    content: Vec<ChatContent<'a>>,
}

#[derive(Debug, Serialize)]
struct ChatContent<'a> {
    #[serde(rename = "type")]
    kind: &'a str,
    text: &'a str,
}

#[derive(Debug, Deserialize)]
struct ResponsesReply {
    output: Vec<OutputMessage>,
}

#[derive(Debug, Deserialize)]
struct OutputMessage {
    #[allow(dead_code)]
    role: Option<String>,
    content: Vec<OutputContent>,
}

#[derive(Debug, Deserialize)]
struct OutputContent {
    #[serde(rename = "type")]
    kind: String,
    text: Option<String>,
}

#[derive(Debug, Serialize)]
struct RefreshRequest<'a> {
    client_id: &'static str,
    grant_type: &'static str,
    refresh_token: &'a str,
    scope: &'static str,
}

#[derive(Debug, Deserialize)]
struct RefreshResponse {
    id_token: String,
    access_token: Option<String>,
    refresh_token: Option<String>,
}

#[derive(Debug, Deserialize)]
struct IdClaims {
    #[serde(rename = "https://api.openai.com/auth")]
    auth: Option<AuthClaims>,
}

#[derive(Debug, Deserialize)]
struct AuthClaims {
    chatgpt_account_id: Option<String>,
}

fn main() -> Result<()> {
    // --- auth.json ÏúÑÏπò Ï∞æÍ∏∞ Î∞è ÏûêÍ≤© ÌôïÏù∏ ---
    let auth_path = if let Ok(path) = std::env::var("CODEX_HOME") {
        let candidate = PathBuf::from(path).join("auth.json");
        if candidate.exists() {
            candidate
        } else {
            return Err(anyhow!("CODEX_HOME/auth.jsonÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."));
        }
    } else {
        let home = dirs::home_dir().ok_or_else(|| anyhow!("Ìôà ÎîîÎ†âÌÑ∞Î¶¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."))?;
        let candidate = home.join(".codex/auth.json");
        if candidate.exists() {
            candidate
        } else {
            return Err(anyhow!(
                "~/.codex/auth.jsonÏù¥ ÏóÜÏäµÎãàÎã§. codex login ÌõÑ Îã§Ïãú ÏãúÎèÑÌïòÏÑ∏Ïöî."
            ));
        }
    };

    let raw_auth = fs::read_to_string(&auth_path)
        .with_context(|| format!("auth.json ÏùΩÍ∏∞ Ïã§Ìå®: {}", auth_path.display()))?;
    let parsed_auth: AuthJson = serde_json::from_str(&raw_auth).context("auth.json ÌååÏã± Ïã§Ìå®")?;

    let credential = if let Some(api_key) = parsed_auth
        .openai_api_key
        .as_ref()
        .filter(|value| !value.trim().is_empty())
    {
        Credential::ApiKey(api_key.to_string())
    } else if let Some(tokens) = parsed_auth.tokens.clone() {
        if tokens.access_token.is_some() || tokens.refresh_token.is_some() {
            Credential::ChatGpt(tokens)
        } else {
            return Err(anyhow!(
                "auth.jsonÏóê access_token ÎòêÎäî refresh_tokenÏù¥ ÏóÜÏäµÎãàÎã§."
            ));
        }
    } else {
        return Err(anyhow!("auth.jsonÏóêÏÑú ÏÇ¨Ïö©Ìï† ÌÜ†ÌÅ∞ÏùÑ Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§."));
    };

    // --- ÏÇ¨Ïö©Ïûê ÏûÖÎ†• ---
    print!("ÏÇ¨Ïö©Ïûê ÏûÖÎ†• > ");
    io::stdout().flush().ok();
    let mut prompt = String::new();
    io::stdin()
        .read_line(&mut prompt)
        .context("ÏûÖÎ†• ÏùΩÍ∏∞ Ïã§Ìå®")?;
    let prompt = prompt.trim().to_string();
    if prompt.is_empty() {
        return Err(anyhow!("Îπà ÌîÑÎ°¨ÌîÑÌä∏ÏûÖÎãàÎã§."));
    }

    // --- ÏûêÍ≤©Ïóê Îî∞Îùº OpenAI ÎòêÎäî ChatGPT Ìò∏Ï∂ú ---
    let reply = match credential {
        Credential::ApiKey(api_key) => {
            let client = Client::new();
            let body = ChatRequest {
                model: CHATGPT_MODEL,
                input: vec![ChatInput {
                    role: "user",
                    content: vec![ChatContent {
                        kind: "input_text",
                        text: &prompt,
                    }],
                }],
                instructions: DEFAULT_INSTRUCTIONS,
                stream: false,
                store: false,
            };

            let response = client
                .post(OPENAI_RESPONSES_URL)
                .bearer_auth(&api_key)
                .header("Content-Type", "application/json")
                .json(&body)
                .send()
                .context("OpenAI API ÏöîÏ≤≠ Ïã§Ìå®")?;

            if response.status() == StatusCode::UNAUTHORIZED {
                return Err(anyhow!(
                    "Ïù∏Ï¶ùÏù¥ Í±∞Î∂ÄÎêòÏóàÏäµÎãàÎã§. OPENAI_API_KEYÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî."
                ));
            }

            let status = response.status();
            let text_body = response.text().context("ÏùëÎãµ Î≥∏Î¨∏ ÏùΩÍ∏∞ Ïã§Ìå®")?;
            if !status.is_success() {
                return Err(anyhow!("API Ïò§Î•ò ({status}): {text_body}"));
            }

            let reply: ResponsesReply = serde_json::from_str(&text_body)?;
            reply
                .output
                .into_iter()
                .flat_map(|message| message.content)
                .find_map(|piece| (piece.kind == "output_text").then(|| piece.text).flatten())
                .ok_or_else(|| anyhow!("ÏùëÎãµÏóêÏÑú output_textÎ•º Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§."))?
        }
        Credential::ChatGpt(mut tokens) => {
            println!("‚öôÔ∏è  auth.jsonÏùò ÌÜ†ÌÅ∞ÏùÑ Ïù¥Ïö©Ìï¥ ChatGPT Î∞±ÏóîÎìúÎ•º Ìò∏Ï∂úÌï©ÎãàÎã§...");
            let client = Client::builder()
                .user_agent("codex-simple-chatgpt-test/0.1")
                .build()
                .context("HTTP ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ± Ïã§Ìå®")?;
            let mut refreshed = false;

            loop {
                // access_token Ï§ÄÎπÑ
                let access_token =
                    match tokens.access_token.as_ref() {
                        Some(token) if !token.trim().is_empty() => token.clone(),
                        _ if !refreshed => {
                            let refresh_token = tokens
                            .refresh_token
                            .as_ref()
                            .filter(|value| !value.trim().is_empty())
                            .ok_or_else(|| anyhow!(
                                "refresh_tokenÏù¥ ÏóÜÏäµÎãàÎã§. codex loginÏúºÎ°ú Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî."
                            ))?;
                            println!("üîÑ refresh_tokenÏúºÎ°ú ÌÜ†ÌÅ∞ÏùÑ Í∞±Ïã†Ìï©ÎãàÎã§...");
                            let refresh_request = RefreshRequest {
                                client_id: CLIENT_ID,
                                grant_type: "refresh_token",
                                refresh_token,
                                scope: "openid profile email",
                            };
                            let refresh_response = client
                                .post("https://auth.openai.com/oauth/token")
                                .header("Content-Type", "application/json")
                                .json(&refresh_request)
                                .send()
                                .context("ÌÜ†ÌÅ∞ Í∞±Ïã† ÏöîÏ≤≠ Ïã§Ìå®")?;
                            let status = refresh_response.status();
                            let body = refresh_response
                                .text()
                                .context("ÌÜ†ÌÅ∞ Í∞±Ïã† ÏùëÎãµ ÏùΩÍ∏∞ Ïã§Ìå®")?;
                            if !status.is_success() {
                                return Err(anyhow!("ÌÜ†ÌÅ∞ Í∞±Ïã† Ïã§Ìå® (status: {status}): {body}"));
                            }
                            let updated: RefreshResponse =
                                serde_json::from_str(&body).context("ÌÜ†ÌÅ∞ Í∞±Ïã† ÏùëÎãµ ÌååÏã± Ïã§Ìå®")?;
                            tokens.id_token = updated.id_token;
                            tokens.access_token = updated.access_token.or(tokens.access_token);
                            tokens.refresh_token = updated.refresh_token.or(tokens.refresh_token);
                            refreshed = true;
                            continue;
                        }
                        _ => {
                            return Err(anyhow!(
                                "access_tokenÏù¥ ÏóÜÏäµÎãàÎã§. codex loginÏúºÎ°ú Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî."
                            ));
                        }
                    };

                // chatgpt-account-id Ï∂îÏ∂ú
                let mut parts = tokens.id_token.split('.');
                let (_, payload, _) = match (parts.next(), parts.next(), parts.next()) {
                    (Some(h), Some(p), Some(s))
                        if !h.is_empty() && !p.is_empty() && !s.is_empty() =>
                    {
                        (h, p, s)
                    }
                    _ => return Err(anyhow!("ÏûòÎ™ªÎêú JWT ÌòïÏãù")),
                };
                let payload_bytes = URL_SAFE_NO_PAD
                    .decode(payload)
                    .context("JWT payload ÎîîÏΩîÎî© Ïã§Ìå®")?;
                let claims: IdClaims =
                    serde_json::from_slice(&payload_bytes).context("JWT JSON ÌååÏã± Ïã§Ìå®")?;
                let account_id = claims
                    .auth
                    .and_then(|auth| auth.chatgpt_account_id)
                    .ok_or_else(|| anyhow!("chatgpt_account_id ÌÅ¥Î†àÏûÑÏù¥ ÏóÜÏäµÎãàÎã§."))?;

                // ChatGPT ÏöîÏ≤≠ Ï†ÑÏÜ°
                let conversation_id = Uuid::new_v4().to_string();
                let body = ChatRequest {
                    model: CHATGPT_MODEL,
                    input: vec![ChatInput {
                        role: "user",
                        content: vec![ChatContent {
                            kind: "input_text",
                            text: &prompt,
                        }],
                    }],
                    instructions: DEFAULT_INSTRUCTIONS,
                    stream: true,
                    store: false,
                };

                let response = client
                    .post(format!("{CHATGPT_BASE_URL}/codex/responses"))
                    .bearer_auth(&access_token)
                    .header("Content-Type", "application/json")
                    .header("OpenAI-Beta", "responses=experimental")
                    .header("chatgpt-account-id", account_id)
                    .header("conversation_id", &conversation_id)
                    .header("session_id", &conversation_id)
                    .json(&body)
                    .send()
                    .context("ChatGPT Î∞±ÏóîÎìú ÏöîÏ≤≠ Ïã§Ìå®")?;

                let status = response.status();
                let text_body = response
                    .text()
                    .unwrap_or_else(|_| "<Î≥∏Î¨∏ ÏùΩÍ∏∞ Ïã§Ìå®>".to_string());

                if status == StatusCode::UNAUTHORIZED && !refreshed {
                    // ÏïÑÏßÅ refreshÎ•º Ìïú Î≤àÎèÑ ÌïòÏßÄ ÏïäÏïòÎã§Î©¥ Ìïú Î≤à Îçî Í∞±Ïã†ÏùÑ ÏãúÎèÑÌïòÍ≥† Î∞òÎ≥µ
                    let refresh_token = tokens
                        .refresh_token
                        .as_ref()
                        .filter(|value| !value.trim().is_empty())
                        .ok_or_else(|| {
                            anyhow!(
                                "refresh_tokenÏù¥ ÏóÜÏäµÎãàÎã§. codex loginÏúºÎ°ú Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî."
                            )
                        })?;
                    println!("üîÑ refresh_tokenÏúºÎ°ú ÌÜ†ÌÅ∞ÏùÑ Í∞±Ïã†Ìï©ÎãàÎã§...");
                    let refresh_request = RefreshRequest {
                        client_id: CLIENT_ID,
                        grant_type: "refresh_token",
                        refresh_token,
                        scope: "openid profile email",
                    };
                    let refresh_response = client
                        .post("https://auth.openai.com/oauth/token")
                        .header("Content-Type", "application/json")
                        .json(&refresh_request)
                        .send()
                        .context("ÌÜ†ÌÅ∞ Í∞±Ïã† ÏöîÏ≤≠ Ïã§Ìå®")?;
                    let status = refresh_response.status();
                    let body = refresh_response
                        .text()
                        .context("ÌÜ†ÌÅ∞ Í∞±Ïã† ÏùëÎãµ ÏùΩÍ∏∞ Ïã§Ìå®")?;
                    if !status.is_success() {
                        return Err(anyhow!("ÌÜ†ÌÅ∞ Í∞±Ïã† Ïã§Ìå® (status: {status}): {body}"));
                    }
                    let updated: RefreshResponse =
                        serde_json::from_str(&body).context("ÌÜ†ÌÅ∞ Í∞±Ïã† ÏùëÎãµ ÌååÏã± Ïã§Ìå®")?;
                    tokens.id_token = updated.id_token;
                    tokens.access_token = updated.access_token.or(tokens.access_token);
                    tokens.refresh_token = updated.refresh_token.or(tokens.refresh_token);
                    refreshed = true;
                    continue;
                }

                if status == StatusCode::UNAUTHORIZED {
                    return Err(anyhow!(
                        "Í∞±Ïã†Îêú ÌÜ†ÌÅ∞ÏúºÎ°úÎèÑ Ïù∏Ï¶ùÏù¥ Ïã§Ìå®ÌñàÏäµÎãàÎã§. codex loginÏúºÎ°ú Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî."
                    ));
                }

                if !status.is_success() {
                    return Err(anyhow!(
                        "ChatGPT Î∞±ÏóîÎìú Ìò∏Ï∂ú Ïã§Ìå® (status: {status}): {text_body}"
                    ));
                }

                // Ïä§Ìä∏Î¶¨Î∞ç ÏùëÎãµ Ìï¥ÏÑù
                let mut collected = String::new();
                for block in text_body.split("\n\n") {
                    for line in block.lines() {
                        let line = line.trim();
                        if !line.starts_with("data:") {
                            continue;
                        }
                        let data = line.trim_start_matches("data:").trim();
                        if data.is_empty() || data == "[DONE]" {
                            continue;
                        }

                        let event: Value = serde_json::from_str(data)?;
                        match event.get("type").and_then(|v| v.as_str()) {
                            Some("response.output_text.delta") => {
                                if let Some(delta) = event.get("delta").and_then(|v| v.as_str()) {
                                    collected.push_str(delta);
                                }
                            }
                            Some("response.completed") if collected.is_empty() => {
                                if let Some(response) = event.get("response") {
                                    let reply: ResponsesReply =
                                        serde_json::from_value(response.clone())?;
                                    if let Some(text) = reply
                                        .output
                                        .into_iter()
                                        .flat_map(|message| message.content)
                                        .find_map(|piece| {
                                            (piece.kind == "output_text")
                                                .then(|| piece.text)
                                                .flatten()
                                        })
                                    {
                                        collected = text;
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                }

                if collected.is_empty() {
                    return Err(anyhow!("Ïä§Ìä∏Î¶¨Î∞ç ÏùëÎãµÏóêÏÑú ÌÖçÏä§Ìä∏Î•º Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§."));
                }

                break collected;
            }
        }
    };

    println!("\nÏñ¥ÏãúÏä§ÌÑ¥Ìä∏ > {reply}");
    Ok(())
}
